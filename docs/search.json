[
  {
    "objectID": "tutorial_02.html",
    "href": "tutorial_02.html",
    "title": "Tutorial 2: Creating an Atmosphere and Working with Physical Units",
    "section": "",
    "text": "# Some set-up for this document\nusing RetrievalToolbox;\nconst RE = RetrievalToolbox;\nusing Plots; default(fontfamily=\"Helvetica\", titlefontsize=10, labelfontsize=10)\nusing Unitful;"
  },
  {
    "objectID": "tutorial_02.html#the-earthatmosphere-object",
    "href": "tutorial_02.html#the-earthatmosphere-object",
    "title": "Tutorial 2: Creating an Atmosphere and Working with Physical Units",
    "section": "1.1 The EarthAtmosphere Object",
    "text": "1.1 The EarthAtmosphere Object\nRetrievalToolbox features a type that represents a typical atmosphere found here on Earth, of course only containing information that is relevant for typical retrieval applications. Within RetrievalToolbox, we follow the general model of a layered atmosphere in which we assume all relevant quantities to be constant inside that layer. Here we already must make an important observation! The EarthAtmosphere object contains not just one, but two layer systems: one representing the vertical grid which the inversion will see, and a second one on which meteorological quantities are defined. While possibly confusing at first, this set-up allows us to be much more flexible with respect to our choices in setting up the retrieval algorithm.\n\n1.1.1 The Retrieval and Meteorological Grids\nThe choice of pressure grid in a given retrieval application is based on a number of factors, such as computational performance, type of instrument from whose measurements we are trying to retrieve gases, and so on. More layers usually means slower forward model, as the radiative transfer solver has to do more work. On the other hand, we might find that we need more vertical layers to account for e.g.¬†scatterers that are located in different parts of the atmosphere and a coarse layering structure would not allow us to reasonably model those. We recommend reading the appropriate section in (Rodgers 2000, vol. 2, sec. 10.3.1) to learn more about optimal choices for the retrieval grid.\nIn general, we want to be highly flexible when making that choice regarding this retrieval grid.\nFurther, most retrieval applications require meteorological profiles. For retrievals in the short-wave infrared, the most commonly uses ones are profiles of temperature and specific humidity. It is also highly common for these meteorological profiles to be derived from modern forecasting systems or reanalysis products, both tend to have much higher vertical resolution than most retrieval grids. We aim to retain the higher resolution of those MET profiles, and thus RetrievalToolbox has a dedicated space for those profiles. Figure¬†1 shows an illustration of two possible grids.\n\n\n\n\n\n\nNote\n\n\n\nThe retrieval and meteorological grids are fully independent of each other! There is no general requirement that one must be finer resolved than the other one, and they could be the same!\n\n\n\n\n\n\n\n\nFigure¬†1: The retrieval pressure grid (left) compared to the meteorological grid (right).\n\n\n\nNote the convention in Figure¬†1! By this convention, we order the atmosphere with a running index starting at 1 from the top. p_1 thus refer to the top-of-atmosphere (TOA) level in this figure. Also note that we use the same convention when indexing layers rather than levels. The first layer, situated between levels p_1 and p_2 also has index 1.\n\n\n\n\n\n\nWarning\n\n\n\nHandling level and layer-related quantities can easily cause confusion and requires attention! In general, there is no guaranteed method of learning whether a quantity is defined with respect to layers or levels, other than understanding the nature of that quantity itself. Make sure to consult on-line and in-line documentation of the related functions!\n\n\nThe meteorological grid and its associated profiles (temperature T, specific humidity q, altitude z and local gravity g) are used mostly in the calculation of the optical properties that later enter the radiative transfer calculations and are of utmost importance.\nWe can illustrate this by a specific example. The quantity of interest there is the optical depth due to some gas absorber, within layer l = 1:\n\n    \\tau_l = \\int_{p_2}^{p_1} \\underbrace{\\dfrac{1 - q(p)}{g(p) \\cdot M_{\\mathrm{dry}}}}_{\\text{number of dry-air molecules}} \\cdot \\overbrace{c_\\text{gas}(p)}^{\\text{concentration of gas}} \\cdot \\underbrace{k(p)}_{\\text{gas cross section}} \\; \\mathrm{d}p\n\\tag{1}\nWithout going into the details about how one numerically evaluates this integral, we can identify the various terms in Equation¬†1 and whether they belong to the retrieval or the meteorological grid.\nThe gas concentration c_\\text{gas}(p) is based off a profile that is likely connected to the retrieval grid. For the sake of this example, let us imagine this particular gas represents a target gas that we want to retrieve from a measurement, and therefore the profile is defined on the retrieval grid. In RetrievalToolbox, gases to be retrieved are defined on pressure levels p_i and values for any arbitrary p are obtained through linear interpolation in (linear) pressure.\nThe two meteorological pressure-dependent variables q(p) (specific humdity) and g(p) (local gravity) are discretized on their own grid (the right grid in Figure¬†1). When evaluating q(p) or g(p) for arbitrary p, the respective values are obtained via linear interpolation on their own meteorological grid.\nLastly, the evaluation of the gas cross section k(p) is actually performed in a completely different grid that either of the two shown in Figure¬†1. As mentioned in another tutorial (Tutorial 1), spectroscopic data is sampled on its own pressure and temperature levels.\nNote however the following. When we have to evaluate the integrand in Equation¬†1 at some arbitrary p, we must also look up k(p). Earlier, we learned that k(p) is really k(p,T,c_\\text{H$_2$O}), so we must also know what the temperature and the water vapor mole fraction is for any given pressure in the model atmosphere. The temperature profile is defined on the MET grid, so we can easily infer T \\rightarrow T(p). While the water vapor mole fraction c_\\text{H$_2$O} is not explicitly stored, we can first infer the specific humidity at any given p as q \\rightarrow q(p) and then calculate c_\\text{H$_2$O}(q), so that we can finally evaluate the cross section k as k(p, T(p), c_\\text{H$_2$O}(q(p))).\n\n\n1.1.2 Type definition\nThe definition of the EarthAtmosphere object is shown below, with all type fields having verbose names to make it clear what they represent - especially whether they belong to pressure layers or pressure levels.\n\n\n\n\n\n\nEarthAtmosphere\n\n\n\n\n\n\natm_elements::Vector{&lt;:AbstractAtmosphereElement}: Vector of atmosphere elements present in this atmosphere\nN_level::Int64: Number of retrieval levels in this atmosphere\nN_layer::Int64: Number of retrieval layers in this atmosphere\npressure_levels::Vector{T} where T&lt;:AbstractFloat: Pressure level locations\npressure_layers::Vector{T} where T&lt;:AbstractFloat: Mid-layer pressure locations\npressure_unit::Unitful.Units{U, ùêå ùêã‚Åª¬π ùêì‚Åª¬≤} where U: Pressure unit\nN_met_level::Int64: Number of meteorological levels in this atmosphere\nN_met_layer::Int64: Number of meteorological layers in this atmosphere\nmet_pressure_levels::Vector{T} where T&lt;:AbstractFloat: Meteorological pressure level locations\nmet_pressure_layers::Vector{T} where T&lt;:AbstractFloat: Mid-layer pressure locations for meteorology\nmet_pressure_unit::Unitful.Units{U, ùêå ùêã‚Åª¬π ùêì‚Åª¬≤} where U: Pressure units for meteorology\ntemperature_levels::Vector{T} where T&lt;:AbstractFloat: Temperatures at pressure levels\ntemperature_layers::Vector{T} where T&lt;:AbstractFloat: Temperatures at mid-layer pressures\ntemperature_unit::Unitful.Units{U, ùöØ, nothing} where U: Temperature unit\nspecific_humidity_levels::Vector{T} where T&lt;:AbstractFloat: Specific humidity at pressure levels\nspecific_humidity_layers::Vector{T} where T&lt;:AbstractFloat: Specific humidity at mid-layer pressures\nspecific_humidity_unit::Unitful.Units{U, NoDims} where U: Specific humidity unit\naltitude_levels::Vector{T} where T&lt;:AbstractFloat: Altitude at pressure levels\naltitude_layers::Vector{T} where T&lt;:AbstractFloat: Altitude at mid-layer pressures\naltitude_unit::Unitful.Units{U, ùêã} where U: Altitude units\ngravity_levels::Vector{T} where T&lt;:AbstractFloat: Gravity at pressure levels\ngravity_layers::Vector{T} where T&lt;:AbstractFloat: Gravity at mid-layer pressures\ngravity_unit::Unitful.Units{U, ùêã ùêì‚Åª¬≤} where U: Gravity unit\n\n\n\n\n\nFor the creation of an EarthAtmosphere object, there is one convenice function that produces the object with a specified number of levels for both grids, and fills them with zeros. This is a recurring design in RetrievalToolbox that users should get familiar with. Objects, especially those of considerable size, are allocated (or created) once, and then altered (or mutated) through the course of the retrieval process. Later tutorials will elaborate on the neccessity of this approach along with best practices.\nThe convenience function used to produce a pre-allocated EarthAtmosphere object is named create_empty_EarthAtmosphere, and can be called in the following way:\n\natm = RE.create_empty_EarthAtmosphere(\n    4, # number of levels for retrieval grid\n    6, # number of levels for MET grid\n    Float64, # data type for all arrays\n    pressure_unit=u\"hPa\", # pressure unit for retrieval grid\n    met_pressure_unit=u\"Pa\", # pressure unit for MET grid\n    temperature_unit=u\"K\", # unit for temperature profile\n    specific_humidity_unit=u\"g/kg\", # unit for specific humidity profile\n    altitude_unit=u\"km\", # unit for altitude profile\n    gravity_unit=u\"m/s^2\", # unit for local gravity profile\n);\n\nThe parameters to the function create_empty_EarthAtmosphere are rather self-explanatory: we first pass the number of levels we want for both retrieval and meteorological grid. Then we must also decide on the data type that we want the arrays of the object to be; 64-bit floats are a good choice in almost all cases. The remaining 6 parameters define the units of the quantities that object contains. Two major things are of note here. First, we can see that there are two different units for the two pressure grids! This means that the retrieval grid could be specified in, e.g., pascal, and the meteorological grid could be specified in, e.g., torr. They can be the same of course. Supplying units explicitly is optional, the function has defined default values."
  },
  {
    "objectID": "tutorial_02.html#ingesting-values-with-units",
    "href": "tutorial_02.html#ingesting-values-with-units",
    "title": "Tutorial 2: Creating an Atmosphere and Working with Physical Units",
    "section": "1.2 Ingesting Values with Units",
    "text": "1.2 Ingesting Values with Units\nFrom here on, we can inspect the object fields in the known manner - for example we can look at vector representing the retrieval pressure grid variables and see that they are all zeros.\n\natm.pressure_levels\n\n4-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\n\n\nThe EarthAtmosphere type itself is not mutable, which means that we cannot replace the vector atm.pressure_level by our desired pressure level. Attempting an operation such as\n\natm.pressure_levels = [1., 100., 500., 1000.]\n\n\nsetfield!: immutable struct of type EarthAtmosphere cannot be changed\n\nStacktrace:\n [1] setproperty!(x::EarthAtmosphere{Float64}, f::Symbol, v::Vector{Float64})\n   @ Base ./Base.jl:53\n [2] top-level scope\n   @ In[6]:1\n\n\n\nwill result in the error seen above. However, we can easily change the contents of the vector without having to violate the immutable nature of the EarthAtmosphere-typed object atm.\n\natm.pressure_levels[:] = [1., 100., 500., 1000.];\natm.pressure_levels\n\n4-element Vector{Float64}:\n    1.0\n  100.0\n  500.0\n 1000.0\n\n\nRecall that [:] is an indexing operation, so rather than trying to assign a new vector to the pressure_levels field of the object atm, we are accessing the contents of the vector that is referenced by atm.pressure_levels.\n\n\n\n\n\n\nTip\n\n\n\nContents of vectors, arrays, lists etc. of objects of mutable types can be altered!\n\n\nAbove we have created the atm object with a specific unit for the retrieval pressure grid, and we can access that unit via\n\natm.pressure_unit\n\nhPa\n\n\nThe new pressure grid we just created is obviously ‚Äúreasonable‚Äù, so to speak - meaning that values from 1 through 1000 hPa make sense within the context of an atmosphere on Earth. Note, however, that there is nothing that would keep us from assigning non-sensical values.\nA very likely error to occur is the mix-up of units. We can demonstrate a possible scenario by pretending we obtain our retrieval grid from some external source, like a configuration script or a file containing our desired grid. Further, we will pretend that those values were initially calculated in units of pascal (Pa) rather than hectopascal (hPa).\n\n# Note: Julia allows \"_\"-separators in numbers to make them visually more obvious to readers\nrgrid = [100., 300., 50_000., 100_000.]\natm.pressure_levels[:] = rgrid\n\n4-element Vector{Float64}:\n    100.0\n    300.0\n  50000.0\n 100000.0\n\n\nNow neither RetrievalToolbox nor Julia have any complaints about this, we have mostly just copied the contents of some vector into the memory space of another vector. Like in all scientific programming, it is the responsibility of the user to ensure that the correct values are fed into objects and functions. The most classic way to do this would be the following: we know we obtain the data in units of pascal, and we know that our object knows its retrieval grid in units of hectopascal, so we make the appropriate conversion before assigment and comment somewhere in our code why we did so:\n\n# Divide by 100 since `rgrid` is in Pa\natm.pressure_levels[:] = rgrid ./ 100\n\n4-element Vector{Float64}:\n    1.0\n    3.0\n  500.0\n 1000.0\n\n\nThe above solution is perfectly fine, however we can make a slightly smarter choice. If we know the units of the source data, we can attach those to the data like so:\n\nrgrid = [100., 300., 50_000., 100_000.]u\"Pa\"\n\n4-element Vector{Quantity{Float64, ùêå ùêã‚Åª¬π ùêì‚Åª¬≤, Unitful.FreeUnits{(Pa,), ùêå ùêã‚Åª¬π ùêì‚Åª¬≤, nothing}}}:\n    100.0 Pa\n    300.0 Pa\n  50000.0 Pa\n 100000.0 Pa\n\n\nNow rgrid is not just a Float64 vector, but a vector of a different type, as evidenced by the output in the code cell above. As such, we can no longer simply copy the contents of rgrid into the contents of atm.pressure_levels, since Julia would throw an error due to the two types being incompatible. We must first make an appropriate conversion, and then extract the numerical values that we can then copy to atm.pressure_levels.\n\natm.pressure_levels[:] = ustrip(rgrid .|&gt; atm.pressure_unit);\natm.pressure_levels\n\n4-element Vector{Float64}:\n    1.0\n    3.0\n  500.0\n 1000.0\n\n\nThe code above handles performs two operations. First, the vector rgrid is being converted into a new vector with units of atm.pressure_unit (hectopascal in our case). The |&gt; is an infix operator in Julia which applies some function on the right-hand side to some expression on the left-hand side. Since rgrid is a vector rather than a number, we must pre-fix with a . to call the broadcast operation which in turn will apply the infix operation on all elements of rgrid. This first operation leaves us with a new vector in which the numerical contents have been appropriately converted from the original units (Pa) to the new ones (hPa). Feel free to experiment with different, compatible units:\n\nrgrid .|&gt; u\"atm\"\n\n4-element Vector{Quantity{Float64, ùêå ùêã‚Åª¬π ùêì‚Åª¬≤, Unitful.FreeUnits{(atm,), ùêå ùêã‚Åª¬π ùêì‚Åª¬≤, nothing}}}:\n 0.0009869232667160128 atm\n 0.0029607698001480384 atm\n 0.4934616333580064 atm\n 0.9869232667160128 atm\n\n\nNote that after such a conversion has taken place, the resulting vector is still a vector whose elements are of some Unitful-type which are not compatible with the contents of atm.pressure_levels. The last step takes care of this: the ustrip function (provided by Unitful.jl) returns a view of the vector that allows copying over the numerical contents only.\n\nustrip(rgrid .|&gt; u\"atm\")\n\n4-element reinterpret(Float64, ::Vector{Quantity{Float64, ùêå ùêã‚Åª¬π ùêì‚Åª¬≤, Unitful.FreeUnits{(atm,), ùêå ùêã‚Åª¬π ùêì‚Åª¬≤, nothing}}}):\n 0.0009869232667160128\n 0.0029607698001480384\n 0.4934616333580064\n 0.9869232667160128\n\n\nNote that the ustrip function, when called on an array (or vector), returns a view onto the underlying array data, whereas calling ustrip on a scalar Unitful-type object returns a new value:\n\nustrip(5.7u\"km\")\n\n5.7\n\n\nThe advatage of this approach is clear: our retrieval application now automatically handles the unit conversion. Think of other examples. Meteorological data tends to come in netCDF formats (or similar) in which each variable contains appropriate metadata that describes its units. The lack of hard-coding these units makes the retrieval application more resilient against these conversion errors which could arise when, for example, changing data sources."
  },
  {
    "objectID": "tutorial_02.html#summary-and-take-aways",
    "href": "tutorial_02.html#summary-and-take-aways",
    "title": "Tutorial 2: Creating an Atmosphere and Working with Physical Units",
    "section": "1.3 Summary and Take-aways!",
    "text": "1.3 Summary and Take-aways!\nThis section introduces some very important concepts, hence we want to emphasize the key take-aways.\n\nRetrievalToolbox is designed such that certain objects must be created (allocated) once and then fed with appriate numerical values.\n\nDue to Julia‚Äôs lack of manual memory management (we cannot explicitly free memory), creating large arrays over and over again leads to dramatic performance loss when the garbage collector has to be called repeatedly1\nIn general, this requires that retrieval applications built with RetrievalToolbox must do some up-front work to create necessary objects and then change the values inside those objects, as appropriate.\nSome parametric types offered by RetrievalToolbox are mutable, whereas others are not. There is no good rule as to which type is mutable or immutable, but a good rule of thumb is: if you cannot change a value after creating the object, you probably shouldn‚Äôt. Mutability of RetrievalToolbox types is subject to change due to updates. For example, the EarthScene type is mutable, since it contains solar anlges, the scene location and time - all quantities that one might want to change after instantiation (when performing retrievals for many scenes).\n\nMany RetrievalToolbox objects have unit fields that describe the unit of their corresponding fields, and they can be leveraged to produce unit-aware algorithms.\n\nThis feature can be used to dynamically incorporate the units of source data (e.g.¬†meteorological model ouptut) and match it with user-preferred units on the algorithm side."
  },
  {
    "objectID": "tutorial_02.html#summary-and-a-useful-convenience-function",
    "href": "tutorial_02.html#summary-and-a-useful-convenience-function",
    "title": "Tutorial 2: Creating an Atmosphere and Working with Physical Units",
    "section": "2.1 Summary and a Useful Convenience Function",
    "text": "2.1 Summary and a Useful Convenience Function\nThe prior section intends to emphasize the role of units and how they are used within RE. To summarize:\n\nQuantities that have units are stored as ‚Äúnormal‚Äù number-types (or number-type arrays). A corresponding field states the units of those.\n\nUsing number-type arrays, e.g.¬†of Matrix{Float64}, allows certain mathematical operations to be performed much faster, which is why RetrievalToolbox takes the approach of using a seperate variable that stores unit information. In principle, it is possible to make use of arrays with attached units - but early tests have shown that the current approach is more performant.\n\nAt all times, users must be aware of units, which quantities have units attached, and how they enter various RetrievalToolbox objects.\n\nAs per the design goals of RetrievalToolbox, there is no over-arching mechanism that controls how quantities flow from data source to be part of RetrievalToolbox-provided objects or functions. Users are free to design that route themselves as they see fit for their application. However, users must always make sure they understand which quantities have units attached to them. Lack of awareness can lead to calcluation errors.\n\n\n\n\n\n\nWarning\n\n\n\nRetrievalToolbox does not evaluate users‚Äô handling of unit-attached quantities. It is the user‚Äôs responsibility to ensure that the RetrievalToolbox object units and the corresponding numerical values match!\n\n\nWhile we have used explicit formulations in the section above to learn about how to deal with units, there is a helpful convience function provided by RetrievalToolbox that makes the typing a little more compact.\nInstead of writing\n\natm.specific_humidity_levels[:] .= q .|&gt; atm.specific_humidity_unit .|&gt; ustrip\n\n6-element view(::Vector{Float64}, :) with eltype Float64:\n 0.1\n 0.2\n 0.35\n 0.35\n 0.75\n 2.0\n\n\nwe can use the convenience function ingest! to copy over a numerical value (or the contents of some array) into a RetrievalToolbox object. The unit conversion is handled by the function itself.\n\nRE.ingest!(atm, :specific_humidity_levels, q)\n\nNote that there are two specialized implementations of the function, so bother number-type and array-type quantities can be ingested into RetrievalToolbox objects very efficiently this way. Also, the target must be valid in the sense that the RetrievalToolbox object must possess both a field, say obj.field, and the accompanying obj.field_unit.\n\n\n\n\n\n\nTip\n\n\n\nIt is a Julia convention, that functions which modify one or more of its arguments, have an exclamation mark at the end. Users can spot immediately that ingest! modifies the atm object!"
  },
  {
    "objectID": "tutorial_02.html#footnotes",
    "href": "tutorial_02.html#footnotes",
    "title": "Tutorial 2: Creating an Atmosphere and Working with Physical Units",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nSee e.g.¬†https://docs.julialang.org/en/v1/manual/performance-tips/#Pre-allocating-outputs‚Ü©Ô∏é"
  },
  {
    "objectID": "tutorial_01.html",
    "href": "tutorial_01.html",
    "title": "Tutorial 1: Spectroscopy and Gases",
    "section": "",
    "text": "Arguably, one of the most fundamental quantities in a retrieval algorithm is the gas spectroscopy. Spectroscopy characterizes the absorption of light due to the various gas species for a given spectral interval and atmospheric conditions (mostly temperature and pressure).\nAs a reminder, we often want to calculate the optical depth due to gas absorption, and thus need to evaluate expressions such as this: \n\\tau(\\lambda) \\approx \\int_{p_1}^{p_2} k(\\lambda, p) \\; N_{\\mathrm{dry}} \\; \\mathrm{d}p,\n where p_1 and p_2 are two pressure values, usually the boundaries of some pressure layer, N_{\\mathrm{dry}} is the total number of dry air molecules. k is the absorption cross section for some gas, here written as a function of both wavelength \\lambda and pressure p.\n\n\n\n\n\n\nGoal of this tutorial\n\n\n\nIn this tutorial, we want to introduce new users of RetrievalToolbox to become familiar with the general usage of the toolkit. Prior experience with the Julia language is helpful, but not required. In the same manner, understanding the background of gas spectroscopy and its role in trace gas retrievals is also helpful."
  },
  {
    "objectID": "tutorial_01.html#sec-array-slicing",
    "href": "tutorial_01.html#sec-array-slicing",
    "title": "Tutorial 1: Spectroscopy and Gases",
    "section": "3.1 Intermission: array slicing and views",
    "text": "3.1 Intermission: array slicing and views\nThis is a good opportunity to mention some aspects about array slicing in Julia, which might behave differently from what users are familiar with in other programming languages. Users highly familiar with Julia can skip this section and move on to Section¬†3.2.\n\n\n\n\n\n\nTip\n\n\n\nReminder! Julia, by default, uses 1-based indexing for enumerations or vectors, arrays, and lists.\n\n\nAt first glance, array slicing is very similar to that of Numpy Python library, of Fortran array operations. If some array A is declared, then using the colon : allows to slice through one or more axes. To illustrate, we can define a matrix A, which we set to have four rows and 3 columns:\n\nA = [\n    1. 2. 3.;\n    4. 5. 6.;\n    7. 8. 9.;\n    10. 11. 12.;\n    ]\n\n4√ó3 Matrix{Float64}:\n  1.0   2.0   3.0\n  4.0   5.0   6.0\n  7.0   8.0   9.0\n 10.0  11.0  12.0\n\n\nAnd we can see that Julia produces the expected object - note that Matrix is a Julia short-hand type for an Array with 2 dimenions. Accessing all elements of the second column, for example is done like this:\n\nA[:,2]\n\n4-element Vector{Float64}:\n  2.0\n  5.0\n  8.0\n 11.0\n\n\nOr getting all elements of the third row is done like so, with the expected result:\n\nA[3,:]\n\n3-element Vector{Float64}:\n 7.0\n 8.0\n 9.0\n\n\nBounds-checking is enabled by default, so attempting to access an out-of-bounds index usually results in an appropriate error:\n\nA[5,:]\n\n\nBoundsError: attempt to access 4√ó3 Matrix{Float64} at index [5, 1:3]\n\nStacktrace:\n [1] throw_boundserror(A::Matrix{Float64}, I::Tuple{Int64, Base.Slice{Base.OneTo{Int64}}})\n   @ Base ./essentials.jl:14\n [2] checkbounds\n   @ ./abstractarray.jl:699 [inlined]\n [3] _getindex\n   @ ./multidimensional.jl:914 [inlined]\n [4] getindex(::Matrix{Float64}, ::Int64, ::Function)\n   @ Base ./abstractarray.jl:1312\n [5] top-level scope\n   @ In[12]:1\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nJulia‚Äôs memory layout for multi-dimensional arrays is column-major, meaning that elements that are in the same column are located next to each other. Iterating over arrays is thus generally faster over rows first, then columns. Iterating over a 3-dimensional array M[i,j,k] should be done ideally such that the outer-most traverses index i, and the inner-most one loops over k. Real-world performance might not always benefit from re-arranging arrays to be in optimal order, so benchmarking is always encouraged.\n\n\nMoving on, we can peform more advanced slicing in both dimensions, such as taking every second row from the last two columns of A:\n\nA[1:2:end,2:3]\n\n2√ó2 Matrix{Float64}:\n 2.0  3.0\n 8.0  9.0\n\n\nAbove we used the slicing notation start:interval:stop, and end can conveniently be used in Julia to access the last element of some list, vector or array.\nA performance-crucial aspect of array slicing is the fact that accessing arrays in this particular way generally creates a copy that is now a new object. This is a tricky concept, because depending on the statement, the slicing operation behaves in the expected manner. For example, if we want to slice the first row of array A, set those elements to some value, and inspect A again, we see that A has indeed changed.\n\nA[1,:] .= -5\nA\n\n4√ó3 Matrix{Float64}:\n -5.0  -5.0  -5.0\n  4.0   5.0   6.0\n  7.0   8.0   9.0\n 10.0  11.0  12.0\n\n\nIf the slicing operation appears on the left-hand side of an equation, Julia will treat this as instruction to set those elements of A to the values of the right-hand side. This is not true when the slicing operation appears on the right-hand side of an expression like the one below:\n\nB = A[1,:] # A new copy is created\nB[:] .= 0 # We set all elements of B to 0\nprintln(\"B = \", B) # B should be zero\nprintln(\"A[1,:] = \", A[1,:]) # The first row of A should still be -5\n\nB = [0.0, 0.0, 0.0]\nA[1,:] = [-5.0, -5.0, -5.0]\n\n\nIn the first line, A[1,:] indeed creates a new copy of the sub-array (a vector in this case), and is then assigned to the variable with name B. Upon changing B, A remains unaffected.\nOften, we do not necessarily want to create new copy, but have a convenient way of accessing a sub-section of an array via a new symbol. Julia provides the @views macro to do just that. The Julia documentation provides more details, but for now it is enough to know that adding @views to an expression (such as on the right-hand side of an assigment via =) instructs Julia to use views of explicit array operations, rather than producing new copies. Related to the example above, we can simply modify the first line and obtain the result we initially wanted.\n\nB = @views A[1,:] # B is a view upon the first row of A\nB[:] .= 0 # Set B to zero, and thus the first row of A also\nprintln(\"B = \", B) # B is zero\nprintln(\"A[1,:] = \", A[1,:]) # The first row of A is now also zero\n\nB = [0.0, 0.0, 0.0]\nA[1,:] = [0.0, 0.0, 0.0]\n\n\nBeing aware of this behavior is crucial to making functions in Julia highly performant.\n\n\n\n\n\n\nWarning\n\n\n\nExplicit array slicing in expressions, of either full (e.g.¬†[:,:,:]) or partial subsets (e.g.¬†[1:3,:,5:10]) of arrays via the bracket-column notation, will likely spawn new copies of arrays and result in dramatic performance loss as well as unnecessary memory usage and garbage collector strain."
  },
  {
    "objectID": "tutorial_01.html#sec-ABSCO-dimensions",
    "href": "tutorial_01.html#sec-ABSCO-dimensions",
    "title": "Tutorial 1: Spectroscopy and Gases",
    "section": "3.2 ABSCO object dimensions",
    "text": "3.2 ABSCO object dimensions\nThe four axes of the absorption cross sections are accessed via absco_o2.temperature, absco_o2.pressure, absco_o2.broadener_vmrs and absco_o2.wavelength.\n\n\n\n\n\n\nNote\n\n\n\nThe spectral dimension, be it either wavenumber or wavelength, is generally accessed in a special way (more on that in a differentn tutorial). For now, it is sufficient to know that the spectral dimension axis can be accessed with absco_o2.wavelength or absco_o2.ww, both methods are equivalent and return the spectral axis in wavelength units.\n\n\nFinally, the absorption cross section data is easily accessed via absco_o2.cross_section, and should be indexed in the order that is stated in the in-line comment of the type. ABSCO tables, as provided by NASA JPL, are tabulated in a non-uniform manner, so we will first explore the data a little bit.\nThe wavelength and broadener VMR axes are straightforward. As we have seen before, this particular data table was pre-computed for three different H2O VMRs:\n\nabsco_o2.broadener_vmrs\n\n3-element Vector{Float32}:\n 0.0\n 0.03\n 0.06\n\n\nSo accessing all pre-computed cross sections for all available wavelengths, temperatures and pressures, for a fixed water vapor VMR of 0.03 can be done via (lengthy output is suppressed here via the semi-colon at the end of the expression):\n\nidx_h2o = 2\nabsco_o2.cross_section[:,idx_h2o,:,:];\n\nThe pressure dimension corresponds to the last index. For the sake of simplicity, we can check the size of the pressure dimension via\n\nsize(absco_o2.pressures)\n\n(64,)\n\n\nand then simply opt to pick out the 60th element, which corresponds to the following pressure value.\n\nidx_p = 60\nabsco_o2.pressures[idx_p]\n\n97267.98f0\n\n\nNote that the ABSCO object also carries a pressures_unit field, which tells us in which units the corresponding pressure values are stored in:\n\nabsco_o2.pressures_unit\n\nPa\n\n\n\n\n\n\n\n\nNote\n\n\n\nUnits play a big role in RetrievalToolbox, however working with units will be discussed in a later tutorial. For now, we just make note of the fact the pressure axis contains values in units of Pascal.\n\n\nJust like before, we could inspect all cross sections for a broadener VMR of 0.03 that were also calculated for the specific pressure value shown above:\n\nabsco_o2.cross_section[:,idx_h2o,:,idx_p]\n\n600√ó17 Matrix{Float32}:\n 6.04593f-26  6.0069f-26   5.95135f-26  ‚Ä¶  4.68517f-26  4.58305f-26\n 6.07779f-26  6.03896f-26  5.98346f-26     4.71239f-26  4.60975f-26\n 6.11033f-26  6.07169f-26  6.01624f-26     4.74016f-26  4.63699f-26\n 6.14354f-26  6.1051f-26   6.04971f-26     4.7685f-26   4.6648f-26\n 6.17745f-26  6.13921f-26  6.08386f-26     4.79742f-26  4.69317f-26\n 6.21206f-26  6.17402f-26  6.11873f-26  ‚Ä¶  4.82693f-26  4.72212f-26\n 6.2474f-26   6.20956f-26  6.15432f-26     4.85704f-26  4.75166f-26\n 6.28346f-26  6.24583f-26  6.19064f-26     4.88776f-26  4.7818f-26\n 6.32027f-26  6.28285f-26  6.22771f-26     4.9191f-26   4.81255f-26\n 6.35785f-26  6.32064f-26  6.26554f-26     4.95109f-26  4.84392f-26\n 6.3962f-26   6.3592f-26   6.30415f-26  ‚Ä¶  4.98372f-26  4.87594f-26\n 6.43534f-26  6.39856f-26  6.34356f-26     5.01702f-26  4.9086f-26\n 6.4753f-26   6.43873f-26  6.38378f-26     5.05099f-26  4.94193f-26\n ‚ãÆ                                      ‚ã±  ‚ãÆ            \n 3.81777f-26  3.84087f-26  3.85089f-26     3.38265f-26  3.32848f-26\n 3.80005f-26  3.82304f-26  3.83302f-26     3.36732f-26  3.31342f-26\n 3.78262f-26  3.80551f-26  3.81545f-26  ‚Ä¶  3.35225f-26  3.29862f-26\n 3.76548f-26  3.78826f-26  3.79817f-26     3.33744f-26  3.28407f-26\n 3.74861f-26  3.77129f-26  3.78117f-26     3.32288f-26  3.26978f-26\n 3.73202f-26  3.75461f-26  3.76446f-26     3.30857f-26  3.25573f-26\n 3.7157f-26   3.73819f-26  3.74802f-26     3.29451f-26  3.24192f-26\n 3.69965f-26  3.72205f-26  3.73185f-26  ‚Ä¶  3.2807f-26   3.22836f-26\n 3.68386f-26  3.70617f-26  3.71595f-26     3.26712f-26  3.21502f-26\n 3.66833f-26  3.69056f-26  3.70031f-26     3.25378f-26  3.20192f-26\n 3.65305f-26  3.6752f-26   3.68494f-26     3.24067f-26  3.18905f-26\n 3.63803f-26  3.6601f-26   3.66982f-26     3.22779f-26  3.17641f-26\n\n\nThe temperature axis handles differently than the other three axes. Since these gas absorption cross sections were computed for applications in Earth‚Äôs atmosphere, there is an innate relationship between temperature and pressure. In order to make the storage of these cross sections more efficient, the temperature axis was chosen to be two-dimensional: for each pressure grid point, the temperature axis is different.\nBelow, we illustrate this two-dimensional temperature axis (Figure¬†1). The next piece of code plots a line connecting all temperature grid points for each distinct pressure grid point. The first vertical line near 1.0 Pa, colored in blue, spans a temperature range between ~115 K through ~280 K. The next temperature range, valid for the pressure grid point of ~45 Pa spans a different range between ~175 K through ~335 K. The pressure grid itself is not uniform, and absorption cross sections are sampled much more densely in pressure space when entering the tropospheric pressure regime of a few thousand Pascals.\n\nplot(\n    xticks=[1, 10, 100, 1000, 10000, 100000],\n    xlabel=\"Pressure [Pa]\",\n    ylabel=\"Temperature [K]\",\n    xgrid=nothing,\n    ygrid=nothing\n)\n\nnum_T = size(absco_o2.temperatures, 1)\n\nfor p in 1:size(absco_o2.pressures, 1)\n\n    # Ternary expression to use alternating colors\n    mod(p,2) == 0 ? color=:black : color=:blue\n\n    plot!(\n        repeat([absco_o2.pressures[p]], num_T),\n        absco_o2.temperatures[:,p],\n        markershape=:circle,\n        markersize=2,\n        linecolor=color,\n        markerstrokecolor=color,\n        markercolor=color,\n        label=nothing,\n        xscale=:log10,\n    )\nend\nplot!(\n    absco_o2.pressures,\n    absco_o2.temperatures',\n    linecolor=:black,\n    linestyle=:dash,\n    alpha=0.25,\n    label=nothing\n)\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n10\n\n\n0\n\n\n10\n\n\n1\n\n\n10\n\n\n2\n\n\n10\n\n\n3\n\n\n10\n\n\n4\n\n\n10\n\n\n5\n\n\nPressure [Pa]\n\n\n\n\n\n\n\n\n150\n\n\n200\n\n\n250\n\n\n300\n\n\n350\n\n\nTemperature [K]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure¬†1: ABSCO temperature axes\n\n\n\n\nFor example, if we want to obtain the cross sections for a given point in the atmosphere, we must first pick our pressure grid point. For the sake of simplicity, we can just assume that this pressure corresponds exactly to the third pressure grid point at\n\nprintln(\"p = $(absco_o2.pressures[3]) Pa\")\n\np = 252.48628 Pa\n\n\nThis means we have to look at the third vertical line from the left in Figure¬†1 (blue) and move to the grid point on that line which corresponds to the temperature of our chosen point in the atmosphere. The temperatures corresponding to that particular pressure grid point are easily found via typing\n\nabsco_o2.temperatures[:, 3]\n\n17-element Vector{Float32}:\n 171.4374\n 181.4374\n 191.4374\n 201.4374\n 211.4374\n 221.4374\n 231.4374\n 241.4374\n 251.4374\n 261.43738\n 271.43738\n 281.43738\n 291.43738\n 301.43738\n 311.43738\n 321.43738\n 331.43738\n\n\nAgain, assuming a convenient case in which the temperature we are looking for falls exactly onto a grid point, for example the 10th temperature value, we can thus obtain all cross section values belonging to this (p,T)-pair like so:\n\nabsco_o2.cross_section[:, :, 10, 3];\n# Output surpressed here\n\nHere it is important to realize that this 2-dimensional pressure grid has consequences for traversing the ABSCO table when moving to a neighbouring point. For example, we have selected now 10 for the temperature index, and 3 for the pressure index. If we move to the next available pressure grid point at index 4, the temperatue value implicitly changes! This can be easily verified by comparing the two temperatue values at\n\nabsco_o2.temperatures[10, 3]\n\n261.43738f0\n\n\nand\n\nabsco_o2.temperatures[10, 4]\n\n240.6375f0\n\n\nThis makes usage of the ABSCO table data slightly more cumbersome in practice, however users generally do not have to worry much about this underlying structure. The sampling of these tables is handled by lower-lying functions of RetrievalToolbox which most users do not have to call themselves.\nLastly, we can look at the spectral dependence of the cross sections. In addition to the temperature-pressure pair we already picked before [10,3] we select the first value in the water vapor broadener axis (equal to a H2O VMR of 0.0). The only remaining axis is the spectral axis equal to the first dimension.\nSince this is a small subset of the full ABSCO table originally devised to cover the full oxygen A-band, we only see two major oxygen absorption lines.\n\nplot(\n    absco_o2.Œª,\n    absco_o2.cross_section[:,1,10,4],\n    label=nothing,\n    xlabel=\"Wavelength [¬µm]\",\n    ylabel=\"Cross section [cm¬≤/molecule]\",\n    yticks=[0, 1e-22, 2.0e-22]\n)\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0.76455\n\n\n0.76460\n\n\n0.76465\n\n\n0.76470\n\n\n0.76475\n\n\n0.76480\n\n\n0.76485\n\n\nWavelength [¬µm]\n\n\n\n\n\n\n0\n\n\n1.0√ó10\n\n\n‚àí22\n\n\n2.0√ó10\n\n\n‚àí22\n\n\nCross section [cm¬≤/molecule]\n\n\n\n\n\nFigure¬†2: ABSCO spectral axis\n\n\n\n\nWe can further zoom into towards the first of the two major absorption lines, and sample the cross section table at different pressure grid points (and implicitly therefore also different temperature grid point values). We see in Figure¬†3 that the cross section for this absorption line becomes shallower but also wider with increasing pressure due to Doppler broadening.\n\nplot()\nfor p in [4, 20, 50]\n    plot!(\n        absco_o2.Œª,\n        absco_o2.cross_section[:,1,10,p],\n        markershape=:circle,\n        markersize=2,\n        label=\"p = $(absco_o2.pressures[p]) Pa\",\n        legend_position=:topleft,\n        xlabel=\"Wavelength [¬µm]\",\n        ylabel=\"Cross section [cm¬≤/molecule]\",\n        yticks=[0, 1e-22, 2.0e-22]\n    )\nend\nxlims!(0.76461, 0.76465)\n# Needed to display the resulting plot since we used `plot!` inside a loop\ncurrent()\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n7.64610√ó10\n\n\n‚àí1\n\n\n7.64620√ó10\n\n\n‚àí1\n\n\n7.64630√ó10\n\n\n‚àí1\n\n\n7.64640√ó10\n\n\n‚àí1\n\n\n7.64650√ó10\n\n\n‚àí1\n\n\nWavelength [¬µm]\n\n\n\n\n\n\n0\n\n\n1.0√ó10\n\n\n‚àí22\n\n\n2.0√ó10\n\n\n‚àí22\n\n\nCross section [cm¬≤/molecule]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\np = 672.7744 Pa\n\n\n\n\np = 10144.036 Pa\n\n\n\n\np = 65556.73 Pa\n\n\n\n\nFigure¬†3: ABSCO spectral axis"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Tutorials for RetrievalToolbox",
    "section": "",
    "text": "Welcome to RetrievalToolbox tutorials! These are a set of tutorials that are meant to slowly guide new users into working with the RetrievalToolbox toolkit, explaining important concepts on the way. No prior knowledge of either RetrievalToolbox or Julia (the programming language in which RetrievalToolbox is written in) are required, however basic knowledge of atmospheric retrievals will help to better understand the material. Given Julia‚Äôs current reach, there are also some mini-lessons inside the various tutorials when some Julia-related behavior is of crucial importance to the workings of RetrievalToolbox routines or designs.\nWe recommend prospective users to start with this set of tutorials to get a good idea of how to work with RetrievalToolbox, since some of the intended use patterns might run contrary to software packages they have used before. One of the main features of RetrievalToolbox is that it does not provide an explicit forward model - as per the design philosophy of this toolset, we want users to be able to better control the flow of data from their sources into their new retrieval algorithm that they build with RetrievalToolbox. Obviously, many of the main moving parts will be taken care of by RetrievalToolbox, users will not have to re-invent the wheel necessarily. Two algorithms built with RetrievalToolbox with the same conceptual ideas will likely produce very similar results. However, users must still write an explicit forward model that is called by one of the RetrievalToolbox solvers. New users will not have to start from scratch, however. Aside from the tutorials, several example implementations of varying degrees of difficulty exist that can guide them to achieve their goals!\nThe tutorials can be read as an online document, however the recommendation is that users follow step by step interactively and experiment along way! To do so, you will need a functioning installation of Julia and have the software library loaded.\n\n\n\n\n\n\nNote\n\n\n\nRetrievalToolbox is, as of now, still under heavy development. Bugs and issues are expected at this stage - users that come across any are encouraged to report them at the GitHub page by filing an issue. Feature requests should be done at the same place.\n\n\n\n1 Installing RetrievalToolbox\nRetrievalToolbox is written in Julia and requires a Julia installation with version &gt;1.10. We recommend using the JuliaUp installation management software that can be downloaded here for various platforms. Once installed, we recommend to create a directory somewhere, and then navigate into it, for example ~/my_tutorials. In there, call Julia from your shell with julia --project=./ (for Linux and MacOS). The --project flag tells Julia that you intend to have an isolated project environment into which you will add certain packages. When you start Julia with that flag, you will only have access to the packages that you installed while being in this project state.\nFrom within the active Julia session, type the following to download and install the RetrievalToolbox package:\nusing Pkg\nPkg.add(path=\"https://www.github.com/US-GHG-Center/RetrievalToolbox.jl\")\nThis will add the package to this new Julia environment, and also add all required packages that RetrievalToolbox itself needs. For now, the base installation is all that is needed. Feel free to read the instructions at the GitHub page on how to also install the XRTM radiative transfer library, which is required for more advanced scenarios.\n\n\n2 Installing required modules\nIn the tutorials, we make use of additional packages that we recommend to be installed as well:\nusing Pkg\nPkg.add([\"Unitful\", \"Plots\"])\nPlots is seemingly the most popular Julia library for plotting at the moment, so we chose it to produce most of the in-line figures in the tutorials. If for some reason you cannot successfully install the Plots package, you can still execute most of the demonstrated calls in the tutorials, but will have to skip those that involve creating figures.\n\n\n3 Obtaining example data\nThere is a small number of extra files that are required to follow some of the steps in the tutorials. The following steps are needed to download those into your tutorial directory (assuming you are in your tutorial directory already, and that wget is available on your computer):\nmkdir data\ncd data\nwget https://github.com/PeterSomkuti/RetrievalToolbox-Tutorials/blob/main/data/o2_spectroscopy_demo.h5\nAlternatively, users can simply clone the full repository some where and link the data directory within (still inside e.g.¬†~/my_tutorials):\ngit clone --depth 1 https://github.com/PeterSomkuti/RetrievalToolbox-Tutorials\nln -s RetrievalToolbox-Tutorials/data data\n\n\n4 Using Jupyter notebooks\nA very convenient way of experimenting with Julia and RetrievalToolbox is a Jupyter notebook environment. These interactive notebooks provide an environment that allows for very convenient execution of Julia commands, as well as produce in-line figures next to program code. Within Julia, one can install and run the environment like so:\nusing Pkg\nPkg.add(\"IJulia\")\nusing Julia\nnotebook(dir=\"./\") # This launches jupyter-lab instance\nUsers who do not have Jupyter installed, will be prompted during the first run. For more information on IJulia, visit here.\n\n\n5 Start the tutorial series\nAfter setting up the required software, start the tutorial series with the first lesson: Tutorial 1."
  },
  {
    "objectID": "LICENSE.html",
    "href": "LICENSE.html",
    "title": "RetrievalToolbox-Tutorials",
    "section": "",
    "text": "BSD 3-Clause License\nCopyright (c) 2025, Peter Somkuti\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\nNeither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ‚ÄúAS IS‚Äù AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Peter Somkuti, 2025"
  },
  {
    "objectID": "tutorial_03.html",
    "href": "tutorial_03.html",
    "title": "Tutorial 3: Spectral Windows, Scenes and Optical Properties",
    "section": "",
    "text": "# Some set-up for this document\nusing RetrievalToolbox;\nconst RE = RetrievalToolbox;\nusing Plots; default(fontfamily=\"JuliaMono-Medium\", titlefontsize=10, labelfontsize=10)\nusing Unitful;"
  },
  {
    "objectID": "tutorial_03.html#introduction-1",
    "href": "tutorial_03.html#introduction-1",
    "title": "Tutorial 3: Spectral Windows, Scenes and Optical Properties",
    "section": "2.1 Introduction",
    "text": "2.1 Introduction\nDuring the beginning stages of setting up a trace gas retrieval algorithm, we must choose the so-called spectral windows. Possibly known as ‚Äúfitting windows‚Äù or just ‚Äúwindows‚Äù, we mean a contiguous section of the spectral dimension, be it wavelength or wavenumber. RetrievalToolbox supports an arbitrary number of spectral windows that can be used for retrievals, and, apart from memory limitations, they can be of any size - so both micro-windows and larger broad-band windows are supported.\nSpectral windows are best defined very early in the retrieval application, since many other RetrievalToolbox objects depend on it. The type structure itself is relatively straightforward: we have to give a name, which is purely for labelling purposes, and then provide the lower and upper limits in either wavelength or wavenumber space. The wavelength or wavenumber limits (denoted here as ww_min and ww_max) represent the ‚Äúwhat the user wants‚Äù spectral boundaries. The third argument, ww_grid is the underlying high-resolution grid. Users can freely choose this grid, it can have regular or irregular intervals, however it must extend beyond the spectral limits as given by ww_min and ww_max. The fourth argument (ww_unit) now defines the units of the spectral grid, and can be any length-type unit (for wavelengths), or any wavenumber unit (inverse length). Finally, the last argument defines a so-called reference point (ww_reference): this is a quantity used for a number of wavelength- (or wavenumber-) dependent objects. For example, if we want to define a surface reflectance that varies spectrally over the range of the spectral window, we likely need a reference point to anchor some polynomial expression.\nBelow is the list of type fields for the SpectralWindow type. Note that the basic constructor (the function that is called when you type RE.SpectralWindow(...)) does not require the N_hires field to be supplied, since it is automatically calculated from the supplied ww_grid parameter.\n\n\n\n\n\n\nSpectralWindow\n\n\n\n\n\n\nwindow_name::String: Label for this spectral window\nww_min::AbstractFloat: This is the ‚Äòwhat user wants‚Äô lower limit\nww_max::AbstractFloat: This is the ‚Äòwhat user wants‚Äô upper limit\nww_grid::Vector{T} where T&lt;:AbstractFloat: Wavelength or wavenumber grid (high-resolution) at the instrument\nww_unit::Union{Unitful.Units{U, ùêã} where U, Unitful.Units{U, ùêã‚Åª¬π} where U}: Wavelength or wavenumber unit\nww_reference::AbstractFloat: Reference Œª or ŒΩ from SV elements which have spectral dependence\nN_hires::Int64: Number of high-resolution spectral elements\n\nA type to hold a spectral window\n\n\n\n\nIt is easier to understand the workings of the SpectralWindow type by example. First, we simply create a new object by calling the type constructor. The example below creates a window that is 1 nm wide with a rather crude spacing of 0.1 nm for demonstration purposes.\n\nwl_unit = u\"nm\"\n\nwl_min = 759.95\nwl_max = 760.25\nwl_buffer = 0.03\nwl_spacing= 0.01\nwl_grid = collect(wl_min-wl_buffer:wl_spacing:wl_max+wl_buffer+wl_spacing)\n\nswin1 = RE.SpectralWindow(\n    \"O2A\", # Label\n    wl_min, # Lower wavelength limit\n    wl_max, # Upper wavelength limit\n    wl_grid, # Hires-grid\n    wl_unit, # Wavelength unit\n    (wl_min + wl_max) / 2 # Reference at center\n)\n\nSpectral window: O2A\nBoundaries: 759.95 to 760.25, in nm.\nN = 37\n\n\nWe can peek into the swin1 object as usual, for example we can look at the actual underlying wavelength grid.\n\nshow(swin1.ww_grid)\n\n[759.9200000000001, 759.9300000000001, 759.94, 759.95, 759.96, 759.97, 759.98, 759.9900000000001, 760.0000000000001, 760.0100000000001, 760.0200000000001, 760.0300000000001, 760.0400000000001, 760.0500000000001, 760.0600000000001, 760.07, 760.08, 760.09, 760.1, 760.1100000000001, 760.1200000000001, 760.1300000000001, 760.1400000000001, 760.1500000000001, 760.1600000000001, 760.1700000000001, 760.1800000000001, 760.19, 760.2, 760.21, 760.22, 760.23, 760.2400000000001, 760.2500000000001, 760.2600000000001, 760.2700000000001, 760.2800000000001]\n\n\nThe role of the wavelength grid is quite important: all optical property and radiative transfer calculations will be performed on that grid. Overall computing performance tends to scale linearly with the number of points in the spectral grid - so doubling the number of points of the spectral window rougly leads to a doubling of the overall forward model execution time."
  },
  {
    "objectID": "tutorial_03.html#wavelengths-and-wavenumbers",
    "href": "tutorial_03.html#wavelengths-and-wavenumbers",
    "title": "Tutorial 3: Spectral Windows, Scenes and Optical Properties",
    "section": "2.2 Wavelengths and Wavenumbers",
    "text": "2.2 Wavelengths and Wavenumbers\nRetrievalToolbox supports both wavelength and wavenumbers as choices for the spectral dimension natively. Additional details are also found in the RetrievalToolbox documentation at [ADD LINK].\nUsers should be able to access the spectral dimension in an explicit way that reflects their initial choice and that helps other users to be constantly aware of whether this particular bit of code was intended for wavelength or wavenumber space. We can access the wavelength-based grid in swin1 as we have done above (swin1.ww_grid), but it is much cleaner to write .wavelength_grid!\n\nshow(swin1.wavelength_grid)\n\n[759.9200000000001, 759.9300000000001, 759.94, 759.95, 759.96, 759.97, 759.98, 759.9900000000001, 760.0000000000001, 760.0100000000001, 760.0200000000001, 760.0300000000001, 760.0400000000001, 760.0500000000001, 760.0600000000001, 760.07, 760.08, 760.09, 760.1, 760.1100000000001, 760.1200000000001, 760.1300000000001, 760.1400000000001, 760.1500000000001, 760.1600000000001, 760.1700000000001, 760.1800000000001, 760.19, 760.2, 760.21, 760.22, 760.23, 760.2400000000001, 760.2500000000001, 760.2600000000001, 760.2700000000001, 760.2800000000001]\n\n\n\nshow(swin1.Œª_grid)\n\n[759.9200000000001, 759.9300000000001, 759.94, 759.95, 759.96, 759.97, 759.98, 759.9900000000001, 760.0000000000001, 760.0100000000001, 760.0200000000001, 760.0300000000001, 760.0400000000001, 760.0500000000001, 760.0600000000001, 760.07, 760.08, 760.09, 760.1, 760.1100000000001, 760.1200000000001, 760.1300000000001, 760.1400000000001, 760.1500000000001, 760.1600000000001, 760.1700000000001, 760.1800000000001, 760.19, 760.2, 760.21, 760.22, 760.23, 760.2400000000001, 760.2500000000001, 760.2600000000001, 760.2700000000001, 760.2800000000001]\n\n\nWith both the unicode lowercase ‚Äúlambda‚Äù (Œª_grid) and wavelength_grid we can access the underlying wavelength grid. The same holds for wavenumber-based spectral windows. Let us define a new window:\n\nwn_unit = u\"cm^-1\"\nwn_min = 5000.0\nwn_max = 5001.0\nwn_buffer = 0.1\nwn_spacing= 0.01\nwn_grid = collect(wn_min-wn_buffer:wn_spacing:wn_max+wn_buffer)\n\nswin2 = RE.SpectralWindow(\n    \"just_test\", # Label\n    wn_min, # Lower wavenumber limit\n    wn_max, # Upper wavenumber limit\n    wn_grid, # Hires-grid\n    wn_unit, # Wavenumber unit\n    (wn_min + wn_max) / 2 # Reference at center\n)\n\nSpectral window: just_test\nBoundaries: 5000.0 to 5001.0, in cm‚Åª¬π.\nN = 121\n\n\nand now access the underlying grid using wavenumber_grid or the lower case greek nu ŒΩ_grid:\n\nshow(swin2.wavenumber_grid)\n\n[4999.9, 4999.91, 4999.92, 4999.93, 4999.94, 4999.95, 4999.96, 4999.97, 4999.98, 4999.99, 5000.0, 5000.01, 5000.02, 5000.03, 5000.04, 5000.05, 5000.06, 5000.07, 5000.08, 5000.09, 5000.1, 5000.11, 5000.12, 5000.13, 5000.14, 5000.15, 5000.16, 5000.17, 5000.18, 5000.19, 5000.2, 5000.21, 5000.22, 5000.23, 5000.24, 5000.25, 5000.26, 5000.27, 5000.28, 5000.29, 5000.3, 5000.31, 5000.32, 5000.33, 5000.34, 5000.35, 5000.36, 5000.37, 5000.38, 5000.39, 5000.4, 5000.41, 5000.42, 5000.43, 5000.44, 5000.45, 5000.46, 5000.47, 5000.48, 5000.49, 5000.5, 5000.51, 5000.52, 5000.53, 5000.54, 5000.55, 5000.56, 5000.57, 5000.58, 5000.59, 5000.6, 5000.61, 5000.62, 5000.63, 5000.64, 5000.65, 5000.66, 5000.67, 5000.68, 5000.69, 5000.7, 5000.71, 5000.72, 5000.73, 5000.74, 5000.75, 5000.76, 5000.77, 5000.78, 5000.79, 5000.8, 5000.81, 5000.82, 5000.83, 5000.84, 5000.85, 5000.86, 5000.87, 5000.88, 5000.89, 5000.9, 5000.91, 5000.92, 5000.93, 5000.94, 5000.95, 5000.96, 5000.97, 5000.98, 5000.99, 5001.0, 5001.01, 5001.02, 5001.03, 5001.04, 5001.05, 5001.06, 5001.07, 5001.08, 5001.09, 5001.1]\n\n\n\nshow(swin2.ŒΩ_grid)\n\n[4999.9, 4999.91, 4999.92, 4999.93, 4999.94, 4999.95, 4999.96, 4999.97, 4999.98, 4999.99, 5000.0, 5000.01, 5000.02, 5000.03, 5000.04, 5000.05, 5000.06, 5000.07, 5000.08, 5000.09, 5000.1, 5000.11, 5000.12, 5000.13, 5000.14, 5000.15, 5000.16, 5000.17, 5000.18, 5000.19, 5000.2, 5000.21, 5000.22, 5000.23, 5000.24, 5000.25, 5000.26, 5000.27, 5000.28, 5000.29, 5000.3, 5000.31, 5000.32, 5000.33, 5000.34, 5000.35, 5000.36, 5000.37, 5000.38, 5000.39, 5000.4, 5000.41, 5000.42, 5000.43, 5000.44, 5000.45, 5000.46, 5000.47, 5000.48, 5000.49, 5000.5, 5000.51, 5000.52, 5000.53, 5000.54, 5000.55, 5000.56, 5000.57, 5000.58, 5000.59, 5000.6, 5000.61, 5000.62, 5000.63, 5000.64, 5000.65, 5000.66, 5000.67, 5000.68, 5000.69, 5000.7, 5000.71, 5000.72, 5000.73, 5000.74, 5000.75, 5000.76, 5000.77, 5000.78, 5000.79, 5000.8, 5000.81, 5000.82, 5000.83, 5000.84, 5000.85, 5000.86, 5000.87, 5000.88, 5000.89, 5000.9, 5000.91, 5000.92, 5000.93, 5000.94, 5000.95, 5000.96, 5000.97, 5000.98, 5000.99, 5001.0, 5001.01, 5001.02, 5001.03, 5001.04, 5001.05, 5001.06, 5001.07, 5001.08, 5001.09, 5001.1]\n\n\nNow what would happen if we tried to access a wavelength-based grid using ŒΩ or wavenumber?\n\nswin1.wavenumber_grid\n\n\nWrong unit! Expected wavelength, but got ŒΩ.\n\nStacktrace:\n [1] error(s::String)\n   @ Base ./error.jl:35\n [2] getproperty(s::SpectralWindow{Float64}, x::Symbol)\n   @ RetrievalToolbox ./none:36\n [3] top-level scope\n   @ In[93]:1\n\n\n\nWe receive an error! RetrievalToolbox clearly is aware of the fact that swin1 was created with a wavelength-compatible unit and throws an error if we attempt to access the underlying grid with a symbol that was meant for wavenumber-compatible objects. This is very deliberate design! Users are encouraged to use wavenumber_grid or wavelength_grid in their codes as to make it clear that it was designed to operate in that particular spectral space. In applications where wavelength and wavenumber are expected to switch often, using ww_grid might be appropriate.\nWithin RetrievalToolbox, the string ww has a special meaning when it comes to type fields. It signals that users can access any quantity that contains ww fully or partially as a type field, using wavelength (or Œª) or wavenumber (or ŒΩ) by replacing ww with the appropriate symbol. For example, swin1.ww_min, swin1.wavelength_min and swin1.Œª_min all access the same object field.\n\n\n\n\n\n\nTip\n\n\n\nEvery RetrievalToolbox type field that starts with ww is intended to be used in either wavelength or wavenumber space! Users can access those fields by replacing the ww part of the type field symbol with either wavelength or Œª for length-compatible spectral units (such as ¬µm), or with either wavenumber or ŒΩ for wavenumber-compatible spectral units (such as cm^-1). For example, the type field .ww_unit can be equivalently accessed as .ŒΩ_unit if the object was created with a wavenumber-compatible unit! There are no known significant performance penalties to doing so."
  },
  {
    "objectID": "tutorial_03.html#illustration-of-a-spectral-window-and-its-relationship-to-spectral-samples",
    "href": "tutorial_03.html#illustration-of-a-spectral-window-and-its-relationship-to-spectral-samples",
    "title": "Tutorial 3: Spectral Windows, Scenes and Optical Properties",
    "section": "2.3 Illustration of a Spectral Window and its Relationship to Spectral Samples",
    "text": "2.3 Illustration of a Spectral Window and its Relationship to Spectral Samples\nIn Figure¬†1, we can see the components of a spectral window, and in this case we have chosen wavelength space for the spectral dimension.\nThe blue line with triangle-shaped markers represents a measurement which is discretized in the spectral dimension into spectral samples. Counting up all triangles in Figure¬†1, there are 30 spectral samples visible in this plot.\nWhen choosing the limits of the spectral window, we usually do that based on the inclusion or exclusion of features in the absorption spectrum. Here, the choice is (without further meaning, just as an example) that we include an absorption feature at ~760.1 nm as well as the surrounding two ‚Äúhumps‚Äù. The vertical, gray lines indicate the location of the window limits, as stored in the .wavelength_min and .wavelength_max fields. This window contains 18 spectral samples of the measurement. The red dots that overlap the x-axis represent an illustration of the high-resolution grid that is stored in .wavelength_grid - these are the spectral points at which the model spectrum will be evaluated. Finally, the gray, dashed line at 760.1 nm represents the reference wavelength .wavelength_ref, which we chose to be at the center of the spectral window. Note that the reference wavelength can be any wavelength and it does not need to be inside the spectral window. Usually, the spectral window center or one of the limits is a convenient choice.\n\n\n\n\n\n\nFigure¬†1: Illustrating the main components of a spectral window, and how they relate to a measurement (blue triangles).\n\n\n\nAlso note that the high-resolution grid does not need to line up at all with the spectral window limits - it just happens to be due to the way we constructed the window. We see the high-resolution grid extend a few intervals beyond the limits - this is required for a successful retrieval! When the instrument spectral response function is applied later on, the high-resolution grid must contain enough data in the spectral dimension such that a forward computation for every spectral sample (blue triangle) can be calculated. Below is an illustration to better visualize this concept (Figure¬†2).\n\n\n\n\n\n\nFigure¬†2: This figure illustrates the neccessity of the high-resolution grid (red dots) to extend beyond the lower wavelength limit of the window (gray vertical line). An example spectral sample (blue triangle) takes spectral contributions from outside the window limits due to the finite width of the spectral response function (ISRF, black), so we must have model calculations for those out-of-window wavelengths."
  },
  {
    "objectID": "tutorial_03.html#first-step-towards-scenes",
    "href": "tutorial_03.html#first-step-towards-scenes",
    "title": "Tutorial 3: Spectral Windows, Scenes and Optical Properties",
    "section": "3.1 First Step Towards Scenes",
    "text": "3.1 First Step Towards Scenes\nWe now ready to move up yet another level in the RetrievalToolbox hiearchy and create a so-called scene. Conceptually, a scene is meant to describe state of the atmosphere and surface(s) along with a number of additional parameters which puts that state into context with the observing instrument (or the measurement).\nThe most important component of the scene is the atmosphere, which we have discussed in the previous tutorial (Tutorial 2). It contains the set-up for our vertical retrieval grid, meteorological profiles, gases and other constituents.\nAlong with the atmosphere, we must also define the surface state(s). At the moment, RetrievalToolbox requires a surface object to be attached to every spectral window that will be considered. We can easily instantiate a new Lambertian surface with the following code:\n\nsurf = RE.LambertianPolynomialSurface(swin1, [0.25])\n\nLambertianPolynomialSurface{Float64}(SpectralWindow: O2A, 0, [0.25])\n\n\nWe must assign the surface to a spectral window, which is the first argument. The second argument in this function is the list of polynomial coefficients. For the sake of simplicity we create a spectrally flat surface, and thus only need one polynomial coefficient - the zeroth order value. The LambertianPolynomialSurface surface type might at a later stage trigger the calculation of surface reflecticity for all high-res spectral points for the spectral window, which requires the evaluation of the albedo \\rho at all spectral points:\n\n\\rho(\\lambda) = \\sum_{i=0}^{N-1} (\\lambda - \\lambda_\\mathrm{ref})^i\n\nThe reference wavelength \\lambda_\\mathrm{ref} will be taken from the swin1.ww_reference field.\nAt first glance, it seems like a circular dependency, but the scene object we want to create later on requires a so-called dictionary that maps a spectral window onto a surface:\n\nsurf_dict = Dict(swin1 =&gt; surf)\n\nDict{SpectralWindow{Float64}, LambertianPolynomialSurface{Float64}} with 1 entry:\n  SpectralWindow: O2A =&gt; LambertianPolynomialSurface{Float64}(SpectralWindow: O‚Ä¶\n\n\nThe next short section explains how dictionaries in Julia work, and why they are a useful tool for RE. Even experienced Julia users might want to read through this sub-section."
  },
  {
    "objectID": "tutorial_03.html#intermission-dictionaries-in-julia",
    "href": "tutorial_03.html#intermission-dictionaries-in-julia",
    "title": "Tutorial 3: Spectral Windows, Scenes and Optical Properties",
    "section": "3.2 Intermission: Dictionaries in Julia",
    "text": "3.2 Intermission: Dictionaries in Julia\nDictionaries in Julia work exactly like those in e.g.¬†Python: they allow one to store the relationship between key and value pairs, mostly for the purpose of accessing some value with a given key. They can be easily created via typing e.g.\n\nd1 = Dict(\"key1\" =&gt; 1, \"key2\" =&gt; 3)\n\nDict{String, Int64} with 2 entries:\n  \"key2\" =&gt; 3\n  \"key1\" =&gt; 1\n\n\nIn Julia, dictionaries are objects of types, so in the example above we have created a dictionary that maps strings onto integers. This is quite different when compared to Python. If we attempt to store a new key-value pair in this already existing dictionary, we find that it only works if we provide a string-based key and an integer-based value (or one that can be implicity converted to one)!\n\nd1[\"key3\"] = 8 # This works\nd1[\"key4\"] = 1.0 # This works too (conversion float -&gt; integer succeeds)\n\nd1[10] = \"key5\" # This does not (integer -&gt; string fails, string -&gt; float fails)\n\n\nMethodError: Cannot `convert` an object of type Int64 to an object of type String\nThe function `convert` exists, but no method is defined for this combination of argument types.\n\nClosest candidates are:\n  convert(::Type{String}, ::Base.JuliaSyntax.Kind)\n   @ Base /Users/julia/.julia/scratchspaces/a66863c6-20e8-4ff4-8a62-49f30b1f605e/agent-cache/default-macmini-x64-5.0/build/default-macmini-x64-5-0/julialang/julia-master/base/JuliaSyntax/src/kinds.jl:975\n  convert(::Type{String}, ::String)\n   @ Base essentials.jl:461\n  convert(::Type{String}, ::FilePathsBase.AbstractPath)\n   @ FilePathsBase ~/.julia/packages/FilePathsBase/NV2We/src/path.jl:120\n  ...\n\n\nStacktrace:\n [1] setindex!(h::Dict{String, Int64}, v0::String, key0::Int64)\n   @ Base ./dict.jl:346\n [2] top-level scope\n   @ In[97]:5\n\n\n\nIf we want to create a dictionary that allows us to use any type for either key or value, we must initially create it as such:\n\nd2 = Dict{Any,Any}()\nd2[\"key1\"] = 123\nd2[3.2] = \"test\"\nd2[(10, 'a')] = sin\n\nd2\n\nDict{Any, Any} with 3 entries:\n  (10, 'a') =&gt; sin\n  3.2       =&gt; \"test\"\n  \"key1\"    =&gt; 123\n\n\nThe dictionary d2 can be populated with almost anything now - the example above shows a string mapped to an integer (\"key1\" =&gt; 1), a 64-bit float mapped to a string (3.2 =&gt; \"test), and finally a tuple mapped to a function ((10, 'a') =&gt; sin)!\nAs always, when it comes to codes that are required to perform very efficiently, one would be wise to steer clear of any data type with Any, since the Julia compiler cannot dispatch specific functions for good performance. However, for most applications the performance for Any-type dictionaries is usually good enough and can be a very convenient way of organizing relationships.\nOne can iterate over dictionaries in the following way:\n\nfor (k,v) in d1 # The braces around k,v are required!\n    println(\"Key $(k) and Value $(v)\")\nend\n\nKey key2 and Value 3\nKey key3 and Value 8\nKey key1 and Value 1\nKey key4 and Value 1\n\n\nWe can already notice something interesting! The order in which the key-value pairs are read out is not the same as the order in which they were added to the dictionary! This is a very important detail about dictionaries in Julia: they are, as of writing of this document, not ordered by insertion and there is no guarantee that the order is preserved between executions of the script. If users need that functionality, there is a Julia package OrderedCollections.jl, which implements an order-preserving dictionary type.\n\n\n\n\n\n\nWarning\n\n\n\nDictionaries in Python (3.7 and up) preserve the order of insertion! In Julia, this is not the case, and the iteration order is not guaranteed!\n\n\nIn many scripting applications, we would use dictionaries in a manner like above where we link strings or integers to other, generally simple objects. In Julia, many more types can be used as dictionary keys, not just numbers, strings or tuples. We can even use our own types! We will use a quick example by creating two new custom types, and use variables of those types as keys in dictionaries.\n\nstruct SS1\n    x\nend\nstruct SS2\n    y\nend\ns1 = SS1([1,2,3])\ns2 = SS2([4,5,6])\n\ntest_dict = Dict(s1 =&gt; \"I am s1\", s2 =&gt; \"I am s2\")\n\nDict{Any, String} with 2 entries:\n  SS1([1, 2, 3]) =&gt; \"I am s1\"\n  SS2([4, 5, 6]) =&gt; \"I am s2\"\n\n\nThese are very simple user types that take one argument each. We can access the contents of the dictionary as follows:\n\ntest_dict[s1]\n\n\"I am s1\"\n\n\nThis feels like expected behavior! We have created a dictionary with some keys, one of those keys is indeed our newly created object s1, so we should be able to access the value \"I am s1‚Äù inside test_dict simply by writing test_dict[s1]. And we see that it works.\nLet us try something very similar: we will create a new object, that is seeminly the same object, and try to access the dictonary in exactly the same way. However, we will see that Julia raises an error!\n\ns3 = SS1([1,2,3])\ntest_dict[s3]\n\n\nKeyError: key SS1([1, 2, 3]) not found\n\nStacktrace:\n [1] getindex(h::Dict{Any, String}, key::SS1)\n   @ Base ./dict.jl:477\n [2] top-level scope\n   @ In[102]:2\n\n\n\nThe underlying reason as to why the above code raises an error is very important to understand! Julia dictionaries are, just like in Python, hash tables. We can use Julia‚Äôs Base.hash function to calculate the hash value of our variables s1 and s3, as well as another object that we just create:\n\ndisplay(Base.hash(s1))\ndisplay(Base.hash(s3))\ndisplay(Base.hash(SS1([1,2,3])))\n\n0xf926f2f597a20787\n\n\n0x81456a8acd84fcd4\n\n\n0xfa6af128b2916ea6\n\n\nEven though all three objects have the same contents in the sense that the values of the arrays [1,2,3] are the same, they produce different hash values! This is due to the fact that the creation of the array [1,2,3] happens on stack memory. So whenever we type [1,2,3] a new array is created at some different part of the memory that is available to Julia.\nIf wanted, we can circumvent this by first creating an array, and afterwards create two objects with that array as the argument:\n\na = [1,2,3]\ns4 = SS1(a)\ns5 = SS1(a)\n\ndisplay(hash(s4))\ndisplay(hash(s5))\n\n0x28b7944f191a2ce5\n\n\n0x28b7944f191a2ce5\n\n\nWe see that the hash value for both s4 and s5 is the same, and Julia cannot differentiate those two objects at all. Therefore, we could use either to access a dictionary:\n\ntest_dict2 = Dict(s4 =&gt; \"I am s4\")\ntest_dict2[s5]\n\n\"I am s4\""
  },
  {
    "objectID": "tutorial_03.html#moving-on-to-scenes",
    "href": "tutorial_03.html#moving-on-to-scenes",
    "title": "Tutorial 3: Spectral Windows, Scenes and Optical Properties",
    "section": "3.3 Moving On To Scenes",
    "text": "3.3 Moving On To Scenes\nReturning back to where we left off before the intermission. There, we created a dictionary that maps our swin1 object of type SpectralWindow onto the Lambertian surface that we also created beforehand.\n\nsurf_dict = Dict(swin1 =&gt; surf)\n\nDict{SpectralWindow{Float64}, LambertianPolynomialSurface{Float64}} with 1 entry:\n  SpectralWindow: O2A =&gt; LambertianPolynomialSurface{Float64}(SpectralWindow: O‚Ä¶\n\n\nWe now understand how surf_dict can be used to access the surf object via swin1. Spectral windows in RetrievalToolbox have arrays in them, so even if we have two separate windows that happen to have the same properties, our swin1 object has a unique hash.\nWe still need a few objects before we can create our scene. Next is the observer. We have to define what type of observation we want to connect to this scene - this is (for now) mostly for the purposes of radiative transfer computations which produce different outputs, depending on the observer type. If we want to use measurements from a space-based instrument, we can use the SatelliteObserver type:\n\nobserver = RE.SatelliteObserver(\n    1.0, # Viewing zenith\n    110.0, # Viewing azimuth\n    zeros(3), # Satellite velocity\n    zeros(3) # Satellite position\n)\n\nSatelliteObserver{Float64, Float64}(1.0, 110.0, [0.0, 0.0, 0.0], [0.0, 0.0, 0.0])\n\n\nWe fill these in with some plausible values. Note that the satellite velocity and satellite position fields are currently unused, so we can safely fill them with zeros. Here we also want to point users the RetrievalToolbox documentation about the problematic ambiguities regarding angular units: [link to RetrievalToolbox doc]. All angular units, such as zenith and azimuth angles, should be entered as degrees without any Unitful units attached to them as to avoid any implicit unwanted unit conversions between degrees and radians.\n\n\n\n\n\n\nWarning\n\n\n\nBe aware of implicit angular unit conversions when using Unitful degree units!\n\n\nThe next required object is a location, and for this exercise we opt for an EarthLocation type, which describes the position on Earth at which the instrument points. Currently, these Earth locations are considered to be point-like, meaning that they do not have any spatial extent. This notion is consistent with the utilized 1-dimensional radiative transfer, so any location represents some idea of a mean atmospheric and surface state of the area covered by the field-of-view of the ground footprint.\n\nlocation = RE.EarthLocation(\n    16.3713,\n    48.2081,\n    200.0,\n    u\"m\"\n)\n\nEarthLocation\nLongitude: 16.3713\nLatitude:  48.2081\nAltitude:  200.0 m\n\n\nThe last separate object needed is a simple DateTime, which is an object type that is part of the Julia standard library to represent a time. It requires loading in a module first, however:\n\nusing Dates\ntime = DateTime(\"2025-02-19T13:00:00\")\n\n2025-02-19T13:00:00\n\n\nAgain, we picked an arbitrary date. So far, the only function which needs this particular data (EarthScene.time) is a function that can calculate the solar Doppler shift between the sun and the Earth location (if explicitly needed).\nWe now have all the components needed to create a scene object. We re-use the code we wrote in the previous tutorial to produce an atmosphere object (Tutorial 2). Readers can un-fold the code cell below to look at the details.\n\n\nCode\natm = RE.create_empty_EarthAtmosphere(\n    4, # number of levels for retrieval grid\n    6, # number of levels for MET grid\n    Float64, # data type for all arrays\n    pressure_unit=u\"hPa\", # pressure unit for retrieval grid\n    met_pressure_unit=u\"Pa\", # pressure unit for MET grid\n    temperature_unit=u\"K\", # unit for temperature profile\n    specific_humidity_unit=u\"g/kg\", # unit for specific humidity profile\n    altitude_unit=u\"km\", # unit for altitude profile\n    gravity_unit=u\"m/s^2\", # unit for local gravity profile\n);\n\nRE.ingest!(atm, :pressure_levels, [1., 100., 500., 1000.]u\"hPa\")\nRE.ingest!(atm, :met_pressure_levels, [5., 65., 200., 400., 650., 950.]u\"hPa\")\nRE.ingest!(atm, :specific_humidity_levels, [0.0001, 0.0002, 0.00035, 0.00035, 0.00075, 0.0020]u\"kg/kg\")\nRE.ingest!(atm, :temperature_levels, [253., 233., 238., 253., 278., 293.]u\"K\")\n\nRE.calculate_layers!(atm)\n\n# Load the spectroscopy\nabsco_o2 = RE.load_ABSCO_spectroscopy(\n    joinpath(\"data\", \"o2_spectroscopy_demo.h5\")\n)\n\n# Define the gas object\ngas_o2 = RE.GasAbsorber(\n    \"O2\",\n    absco_o2,\n    [0.2095, 0.2095, 0.2095, 0.2095],\n    Unitful.NoUnits\n)\n\n# push into our list of atmosphere objects\npush!(atm.atm_elements, gas_o2);\n\n\n\nscene = RE.EarthScene(\n    atm, # Atmosphere\n    surf_dict, # Surface(s)\n    observer, # Observer\n    location, # Scene location\n    12.3, # Solar zenith angle\n    56.7, # Solar azimuth angle\n    time # Time of measurement\n)\n\nEarthScene\n\n\nBefore moving on to use the scene object for computations, let us ponder the relationship and dependencies between the various objects we have created in order to build this. Understanding those connections is helpful since those reflect the needed paths of fundamental calculations that we require for most retrieval applications.\n\n\n\n\n\n---\nconfig:\n    class:\n        hideEmptyMembersBox: true\n---\nclassDiagram\n\n    class SpectralWindow[\"SpectralWindow\\n(shortened)\"]{\n        Number Œª_min\n        Number Œª_max\n    }\n\n    class surfaces\n\n    class LambertianPolynomialSurface[\"LambertianPolynomialSurface\\n(shortened)\"]\n\n    class ABSCOSpectroscopy[\"ABSCOSpectroscopy\\n(shortened)\"]{\n        String filename\n    }\n\n    class GasAbsorber[\"GasAbsorber\\n(shortened)\"]{\n        ABSCOSpectroscopy spectroscopy\n    }\n\n    class EarthAtmosphere[\"EarthAtmosphere\\n(shortened)\"]{\n        AtmosphereElements\n\n        retrieval_pressure_grid\n        met_pressure_grid\n        met_profiles\n        met_profiles_units\n\n    }\n\n    class EarthScene{\n        Dict[SpectralWindow-&gt;AbstractSurfaces] surfaces\n        EarthAtmosphere atm\n        AbstractObserver observer\n        AbstractLocation location\n        Number solar_zenith\n        Number solar_azimuth\n        DateTime time\n    }\n\n    GasAbsorber &lt;-- ABSCOSpectroscopy\n    EarthAtmosphere &lt;-- GasAbsorber\n    EarthScene &lt;-- EarthAtmosphere\n    EarthScene &lt;-- surfaces\n\n    SpectralWindow --&gt; surfaces\n    LambertianPolynomialSurface --&gt; surfaces\n\n\n\n\n\n\n\nThe above schematic shows a stripped-down version of the actual objects and their fields, done mostly for clarity. The EarthScene object is situated at the top right of the diagram, and there are two arrows pointing inward to it. One of the paths show the atmosphere, as defined by the EarthAtmosphere object that contains the various retrieval and meteorological grids and profiles (see Tutorial 2). The atmosphere may have some AtmosphereElements, such as a GasAbsorber which itself needs underlying spectrosopic data. The other arrow shows how surfaces are introduced into the scene. We must first create a surface of type AbstractSurface, in this case we use a LambertianPolynomialSurface - one that has some spectral variability through polynomial coefficients. Then we must have a spectral window to which the surface is attached to. The relationship between surface and spectral window is then determined by the dictionary which maps the spectral window to the surface.\nSimilarly to what we have done before, the convenience of this hierarchy becomes clear when we want to refer to any of the important quantities. Some function that gets passed a EarthScene object scene, can access all these data through the scene itself. For the solar zenith angle, a simple scene.solar_zenith is enough, the retrieval grid, for example, is accessed by scene.atm.pressure_levels. One can keep chaning the dot-operator to get lower-level data. For example, if one needed to write a small function that lists all the spectroscopy file paths for all gases used in this scene, one can do the following:\n\nfunction list_all_spec_fnames(scene::RE.EarthScene)\n\n    # Loop through all atmosphere elements in the atmosphere\n    for ele in scene.atmosphere.atm_elements\n        # Check if this atmosphere element is a GasAbsorber type\n        if ele isa RE.GasAbsorber\n            # Finally, print out the gas name and the spectroscopy file name\n            println(\"Gas $(ele.gas_name) is read from: $(ele.spectroscopy.file_name)\")\n        end\n    end\n\nend\n\n# Note that `scene` was defined above in the collapsed code cell\nlist_all_spec_fnames(scene)\n\nGas O2 is read from: data/o2_spectroscopy_demo.h5\n\n\nNow the above example highlights the way one can walk down the object hiearchy, starting from the uppermost available object (in this case the scene). Observant readers will notice, however, that this particular function does not need anything beyond the list of atmosphere elements, so one could have written the function so that it accepts either the scene.atmosphere or even scene.atmosphere.atm_elements as its argument. In general, most functions inside RetrievalToolbox are set up this way such that functions will operate on the ‚Äúhighest‚Äù required object, which in this case would be the atmosphere. Sometimes it is simply more convenient to have a function act on an object much higher in the hierarchy, for example when it reduces typing. To illustrate this on our example here, we define our function again, but let it act on the atmosphere object:\n\nfunction list_all_spec_fnames(atmosphere::RE.EarthAtmosphere)\n    # Loop through all atmosphere elements in the atmosphere\n    for ele in atmosphere.atm_elements\n        # Check if this atmosphere element is a GasAbsorber type\n        if ele isa RE.GasAbsorber\n            # Finally, print out the gas name and the spectroscopy file name\n            println(\"Gas $(ele.gas_name) is read from: $(ele.spectroscopy.file_name)\")\n        end\n    end\nend\n\nlist_all_spec_fnames (generic function with 2 methods)\n\n\nNow, we can create a very simply wrapper function that calls this for a scene object:\n\n# This now overwrites our very fist function\nlist_all_spec_fnames(scene::EarthScene) = list_all_spec_fnames(scene.atmosphere)\n\nlist_all_spec_fnames (generic function with 2 methods)\n\n\nThis way, we now have two functions at our disposal. We can use this for an atmosphere object (when no scene has yet been created), and we can also use this for the scene itself to which the atmosphere is attached to. Further, the actual code that does the work is only implemented once, so we will only have to edit the code in one place to extend or improve the function, and the changes will occur for any other wrapper function!\n\nlist_all_spec_fnames(scene.atmosphere)\nlist_all_spec_fnames(scene)\n\nGas O2 is read from: data/o2_spectroscopy_demo.h5\nGas O2 is read from: data/o2_spectroscopy_demo.h5\n\n\nTo finish up, we have one last step to do before we calculate optical properties. Optical depths calculations require knowledge of at least the local gravity at the various pressure levels, so we must perform this calculation before doing any further steps:\n\nRE.calculate_altitude_and_gravity!(scene)\n\nThe above function performs the calculation, stores the results in-place with the correct units, and then also provides those values at the mid-layer pressures. We can have a quick look at the profiles:\n\np1 = plot(atm.altitude_levels * atm.altitude_unit, collect(1:atm.N_met_level),\n    lw=2.0, marker=:circle, label=\"Altitude profile\", legend=:bottomright)\nylabel!(\"Met profile level #\");\nyflip!()\np2 = plot(atm.gravity_levels * atm.gravity_unit, collect(1:atm.N_met_level),\n    lw=2.0, marker=:circle, label=\"Gravity profile\", legend=:bottomleft)\nyflip!()\nplot(p1, p2, layout=(1, 2))"
  }
]